========== text-mode
===== today
`(format-time-string "%Y-%m-%d")`$0
========== prog-mode
===== comment
`comment-start`$0
===== todo
`comment-start`TODO: $0
===== fixme
`comment-start`FIXME: $0
========== typescript-ts-mode tsx-ts-mode
===== impf
import { ${2:exports} } from '${1:lib}';$0
========== tsx-ts-mode
===== component
export interface $1Props {
       $3
}
export function ${1:ComponentName}({$4}: $1Props) {
       $0
       return <></>
}
===== self-closing tag
<${1:tag} />$0
===== tag
<${1:tag}${2}>$0</$1>
========== elixir-mode elixir-ts-mode heex-ts-mode
===== dmod
defmodule $1
===== hsig
~H"""
  $1
"""
===== render
def render(assigns) do
    ~H"""
      $0
    """
end
===== self-closing tag
<${1:tag} />$0
===== tag
<${1:tag}${2}>$0</$1>
===== ok tuple
{:ok, $1} = $0
===== ok match
{:ok, $1} -> $0
===== error match
{:error, $1} -> $0
===== assert equals
assert $1 == $0
========== go-ts-mode
===== ife
if err != nil {
	return $0
}
===== ifel
if err != nil {
	log.Fatal(err)
}
$0
===== ife:
if err := $1; err != nil {
	return $0
}
===== errw
fmt.Errorf("${1:context}: %w", ${2:err})$0
===== fn
func ${1:name}($2) $3 {
	$0
}
===== met
func (${1:r} ${2:Type}) ${3:name}($4) $5 {
	$0
}
===== st
type ${1:Name} struct {
	$0
}
===== inf
type ${1:Name} interface {
	$0
}
===== con
const (
	$0
)
===== tdef
type ${1:Name} ${0:string}
===== tf
func Test${1:Name}(t *testing.T) {
	$0
}
===== tft
func Test${1:Name}(t *testing.T) {
	tests := []struct {
		name string
		$2
	}{
		{name: "$3"$4},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			$0
		})
	}
}
===== bench
func Benchmark${1:Name}(b *testing.B) {
	for b.Loop() {
		$0
	}
}
===== main
func main() {
	$0
}
===== init
func init() {
	$0
}
===== fori
for ${1:i} := ${2:0}; $1 < ${3:n}; $1++ {
	$0
}
===== forr
for ${1:_}, ${2:v} := range ${3:collection} {
	$0
}
===== sel
select {
case $1:
	$0
}
===== sw
switch ${1:v} {
case $2:
	$0
}
===== gof
go func() {
	$0
}()
===== ctx
ctx context.Context$0
===== hf
func ${1:handler}(w http.ResponseWriter, r *http.Request) {
	$0
}
===== jsm
${1:Field} ${2:string} \`json:"${1:$(downcase yas-text)}"\`$0
========== emacs-lisp-mode
===== use-package
(use-package $1)